The below document was generated by Claude, the AI.  I think it writes too much and too verbosely sometimes. I wanted to work with it on one design document, but it decided to spawn out lots and lots of them.  Also, I've asked it to specifically start only with the davclient.py file - so the rest of the project is as for now glossed over.

# Async CalDAV Refactoring Design Documents

This directory contains design documents for the async-first CalDAV refactoring project.

## Overview

The goal is to refactor the caldav library to be async-first, with a thin sync wrapper for backward compatibility. This allows us to:

1. Modernize the codebase for async/await
2. Clean up API inconsistencies in the async version
3. Maintain 100% backward compatibility via sync wrapper
4. Minimize code duplication

## Key Documents

### [`SYNC_ASYNC_PATTERNS.md`](SYNC_ASYNC_PATTERNS.md)
**Industry patterns analysis** for libraries supporting both sync and async APIs:
- Sans-I/O pattern (h11, h2, wsproto)
- Unasync code generation (urllib3, httpcore)
- Async-first with sync wrapper
- Comparison table and tradeoffs
- Antipatterns to avoid

### [`PLAYGROUND_BRANCH_ANALYSIS.md`](PLAYGROUND_BRANCH_ANALYSIS.md)
**Playground branch evaluation** comparing the current implementation against industry patterns:
- How the `playground/new_async_api_design` branch implements async-first with sync wrapper
- Event loop management strategies (per-call vs context manager)
- Tradeoffs accepted and alternatives not taken
- Strengths, weaknesses, and potential optimizations

### [`SANS_IO_DESIGN.md`](SANS_IO_DESIGN.md)
**Sans-I/O architecture analysis** - long-term architectural improvement:
- Separates protocol logic from I/O operations
- **API Stability Analysis**: Demonstrates Sans-I/O is internal, public API unchanged
- **Hybrid Approach**: Gradual migration strategy that builds on playground branch
- Code examples for protocol layer and I/O shells
- Comparison with playground branch approach

### [`SANS_IO_IMPLEMENTATION_PLAN.md`](SANS_IO_IMPLEMENTATION_PLAN.md)
**Detailed implementation plan** for Sans-I/O architecture:
- **Starting point**: Playground branch (leverages existing work)
- Seven implementation phases with code examples
- Complete file structure and migration checklist
- Protocol types, XML builders, XML parsers, I/O shells
- Backward compatibility maintained throughout

### [`PROTOCOL_LAYER_USAGE.md`](PROTOCOL_LAYER_USAGE.md)
**Usage guide** for the Sans-I/O protocol layer:
- Quick start with `SyncProtocolClient` and `AsyncProtocolClient`
- Low-level protocol access for maximum control
- Available request builders and response parsers
- Testing without HTTP mocking
- Using custom HTTP libraries

### [`ASYNC_REFACTORING_PLAN.md`](ASYNC_REFACTORING_PLAN.md)
**Master plan** consolidating all decisions. Start here for the complete picture of:
- Architecture (async-first with sync wrapper)
- File structure and implementation phases
- Backward compatibility and deprecation strategy
- API improvements and standardization
- Testing strategy and success criteria

### [`API_ANALYSIS.md`](API_ANALYSIS.md)
Analysis of 10 API inconsistencies in the current davclient.py and proposed fixes for the async API:
- URL parameter handling (optional vs required)
- Dummy parameters (backward compat cruft)
- Body parameter naming inconsistencies
- Method naming improvements
- Parameter standardization

### [`URL_AND_METHOD_RESEARCH.md`](URL_AND_METHOD_RESEARCH.md)
Research on URL semantics and HTTP method wrapper usage:
- How method wrappers are actually used in the codebase
- URL parameter split (optional for query methods, required for resource methods)
- Why `delete(url=None)` would be dangerous
- Dynamic dispatch analysis

### [`ELIMINATE_METHOD_WRAPPERS_ANALYSIS.md`](ELIMINATE_METHOD_WRAPPERS_ANALYSIS.md)
Decision analysis on `DAVObject._query()`:
- Why `_query()` should be eliminated
- Why method wrappers should be kept (mocking, discoverability)
- How callers will use wrappers directly

### [`METHOD_GENERATION_ANALYSIS.md`](METHOD_GENERATION_ANALYSIS.md)
Analysis of manual vs generated HTTP method wrappers:
- Option A: Manual wrappers + helper (recommended)
- Option B: Dynamic generation at runtime
- Option C: Decorator-based generation
- Trade-offs: code size vs clarity vs debuggability

### [`GET_DAVCLIENT_ANALYSIS.md`](GET_DAVCLIENT_ANALYSIS.md)
Analysis of factory function as primary entry point:
- Why `get_davclient()` should be the recommended way
- Environment variable and config file support
- Connection probe feature design
- 12-factor app principles

### [`RUFF_CONFIGURATION_PROPOSAL.md`](RUFF_CONFIGURATION_PROPOSAL.md)
How to configure Ruff formatter/linter for partial codebase adoption:
- Include patterns to apply Ruff only to new/rewritten files
- Configuration reference from icalendar-searcher project
- Four options analyzed (include patterns recommended)
- Gradual expansion strategy

### [`PHASE_1_IMPLEMENTATION.md`](PHASE_1_IMPLEMENTATION.md)
**Implementation status** for Phase 1 (Core Async Client):
- Complete implementation of `async_davclient.py`
- AsyncDAVClient and AsyncDAVResponse classes
- All HTTP method wrappers (propfind, report, etc.)
- Factory function with connection probing
- API improvements applied (standardized parameters, type hints)
- Next steps and known limitations

## Implementation Status

**Current Phase**: Phase 4 Complete ✅ (Sync Wrapper Cleanup)

**Branch**: `playground/new_async_api_design`

**Completed**:
- ✅ Phase 1: Created `async_davclient.py` with `AsyncDAVClient` - [See Implementation Details](PHASE_1_IMPLEMENTATION.md)
- ✅ Phase 2: Created `async_davobject.py` with `AsyncDAVObject`, `AsyncCalendarObjectResource`
- ✅ Phase 3 (Core): Created `async_collection.py` with:
  - `AsyncCalendarSet` - calendars(), make_calendar(), calendar()
  - `AsyncPrincipal` - get_calendar_home_set(), calendars(), calendar_user_address_set()
  - `AsyncCalendar` - _create(), save(), delete(), get_supported_components()
  - Sync wrappers in `collection.py` with `_run_async_*` helpers
- ✅ Phase 3 (Search): Added search methods to `AsyncCalendar`:
  - search() - Full async search using CalDAVSearcher for query building
  - events(), todos(), journals() - Convenience methods
  - event_by_uid(), todo_by_uid(), journal_by_uid(), object_by_uid() - UID lookups

- ✅ Phase 4: Sync wrapper cleanup
  - DAVResponse now accepts AsyncDAVResponse directly
  - Removed mock response conversion (_async_response_to_mock_response)
  - All HTTP method wrappers pass AsyncDAVResponse to DAVResponse

- ✅ Phase 5: Documentation and examples
  - Updated `caldav/__init__.py` to export `get_davclient`
  - Updated `caldav/aio.py` with all async collection classes
  - Created `examples/async_usage_examples.py`
  - Created `docs/source/async.rst` with tutorial and migration guide
  - Updated `README.md` with async examples

**Remaining Work**:
- Optional: Add API reference docs for async classes (autodoc)

## Sans-I/O Implementation Status

**Branch**: `playground/sans_io_asynd_design`

**Completed**:
- ✅ Phase 1-3: Protocol layer foundation
  - `caldav/protocol/types.py` - DAVRequest, DAVResponse, result types
  - `caldav/protocol/xml_builders.py` - 8 pure XML building functions
  - `caldav/protocol/xml_parsers.py` - 5 pure XML parsing functions
- ✅ Phase 4: CalDAVProtocol operations class
  - Request builders for all CalDAV operations
  - Response parsers with structured result types
- ✅ Phase 5: I/O layer abstraction
  - `caldav/io/sync.py` - SyncIO using requests
  - `caldav/io/async_.py` - AsyncIO using aiohttp
- ✅ Phase 6: Protocol-based client classes
  - `caldav/protocol_client.py` - SyncProtocolClient, AsyncProtocolClient
  - 39 unit tests all passing
- ✅ Phase 7: Integration testing
  - `tests/test_protocol_client_integration.py` - 18 integration tests
  - Verified against Radicale and Xandikos servers

**Available for use**:
- `caldav.protocol` - Low-level protocol access
- `caldav.io` - I/O implementations
- `caldav.protocol_client` - High-level protocol clients

See [PROTOCOL_LAYER_USAGE.md](PROTOCOL_LAYER_USAGE.md) for usage guide.

## Long-Term Roadmap

The architecture evolution follows a three-phase plan:

### Phase 1: Async-First (Current - Playground Branch) ✅
- Async-first implementation with sync wrapper
- Single source of truth (async code)
- Acceptable runtime overhead for sync users
- **Status**: Complete and working

### Phase 2: Protocol Extraction (Complete) ✅
- ✅ Protocol layer created: `caldav/protocol/`
- ✅ I/O layer created: `caldav/io/`
- ✅ Protocol-based clients available
- ✅ 57 tests (39 unit + 18 integration) all passing
- Optional: DAVClient internal refactoring to use protocol layer
- Better testability (protocol tests without HTTP mocking)
- Reduced coupling between protocol and I/O

### Phase 3: Full Sans-I/O (Long-term)
- Complete separation of protocol and I/O
- Optional protocol-level API for power users
- Support for alternative HTTP libraries
- **Trigger**: Major version bump (3.0) or community demand

**Key insight**: Sans-I/O is an *internal* architectural improvement. The public API
(`DAVClient`, `Calendar`, etc.) remains unchanged. See [SANS_IO_DESIGN.md](SANS_IO_DESIGN.md)
for detailed analysis.

## Design Principles

Throughout these documents, the following principles guide our decisions:

- **Clarity over cleverness** - Explicit is better than implicit
- **Minimize duplication** - Async-first architecture eliminates sync/async code duplication
- **Backward compatibility** - 100% via sync wrapper, gradual deprecation
- **Type safety** - Full type hints in async API
- **Pythonic** - Follow established Python patterns and conventions
- **Incremental improvement** - Sans-I/O can be adopted gradually without breaking changes
